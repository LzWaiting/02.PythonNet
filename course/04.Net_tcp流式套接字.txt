流式套接字(tcp)
	服务端编程:
		import socket 	# 导入套接字模块
		1. 创建套接字
			sockfd = socket.socket(socket_family = AF_INET,
							   	   socket_type = SOCK_STREAM,
							   	   proto = 0)
			参数含义:
				socket_family:选择地址族类型
					AF_INET --> IPv4
					AF_INET6 --> IPv6
				socket_type:套接字类型
					SOCK_STREAM 流式套接字
					SOCK_DGRAM 数据报套接字
				proto:选择子协议类型
					通常为 0
			返回值:返回套接字对象
		
		2. 绑定服务端地址
			sockfd.bind(addr)	
			功能: 绑定IP地址
			参数: 元组(ip,port)
			返回值:无
		
		3. 设置监听套接字
			sockfd.listen(n)
			功能:将套接字设置为监听套接字,创建监听队列
			参数:n表示监听队列大小
			* 一个监听套接字可以连接多个客户端套接字,但是过程需要一个一个进行
		
		4. 等待处理客户端连接请求
			connfd,addr = sockfd.accept()
			功能:阻塞等待处理客户端连接
			返回值:connfd 	客户端连接套接字
				  addr 		连接的客户端地址
			* 阻塞函数:程序运行过程中遇到阻塞函数则暂停运行,直到某种阻塞条件达成再继续运行

		5. 消息收发
			
			connfd.recv(buffersize)
			功能:接收对应客户端消息
			参数:一次最多接收多少字节
			返回值:接收到的内容
			* 如果没有消息则会阻塞
			
			n = connfd.send(data)
			功能:发送消息给对应客户端
			参数:要发送的内容,必须是bytes格式
			返回值:返回实际发送消息的大小

			*补充函数
			sendall(data)
			功能：发送tcp消息
			参数：要发送的内容，bytes格式
			返回值：成功返回 None;失败产生异常

		6. 关闭套接字
			connfd.close()
			sockfd.close()
			功能:关闭套接字
	tcp客户端
		1. 创建套接字
			* 必须相同类型的套接字才能通信

		2. 建立连接
			socket.connect(server_addr)
			功能:建立连接
			参数:元组,服务端地址

		3. 消息收发
			* 消息收发要和服务端配合,避免两边都出现recv阻塞
		4. 关闭套接字

	套接字传输注意事项：
		1. 监听套接字存在客户端即可发起连接，但是最终连接的处理需要accept进行处理
		2. 如果连接的另外一段退出，则recv会立即返回空子串不再阻塞
		3. 当连接的另一端退出时，再试图send发送就会产生 BrokenPipeError

	网络收发缓冲区（防止频繁的进行硬盘交互）
		send 和 recv 实际上是和缓冲区进行交互，发送缓冲区满时就无法发送，接收缓冲区满时recv 才阻塞
		作用：
			协调收发（处理）速度
			减少交互次数

	tcp 粘包
		产生原因：
			tcp 套接字以字节流方式传输，没有消息边界，发送和接收并不能保证每次发送都及时的被接收
		影响：
			如果每次发送内容表达一个独立的含义，此时可能需要处理粘包，防止产生歧义
		处理方法：
			1. 每次发送的消息添加结尾标志（人为增加消息边界）
			2. 发送数据结构体
			3. 协调收发速度，每次发送后都预留接收时间（适应于不频繁操作）

cookie:
	localhost 			可以被本机用 127.0.0.1
	127.0.0.1			同上
	192.168.10.105		可以被所有人用192.168.10.105访问
	0.0.0.0				可以被所有人用192.168.10.105访问,也可以被自己用127.0.0.1访问



