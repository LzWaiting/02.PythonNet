多进程编程

	import os
	pid = os.fork()
	功能:创建新的进程
	参数:无
	返回值:失败返回一个负数;成功,在原有进程中返回新的进程PID号,在新的进程中返回0

	* 子进程会复制父进程全部代码段,包括fork之前产生的内存空间
	* 子进程从fork 的下一句开始执行,与父进程互不干扰
	* 父子进程的执行顺序是不一定的,父子进程共用一个终端显示
	* 父子进程通常根据fork返回值的差异选择执行不同的代码,所以if结构几乎是fork的固定搭配
	* 父子进程空间独立,操作的都是本空间的内容,互不影响
	* 子进程也有自己的特性,比如PID号,PCB,命令集等

	示例:见fork.py

	获取进程PID
		os.getpid()
		功能:获取当前进程的进程号
		返回值:返回进程号
		os.getppid()
		功能:获取当前进程父进程的PID号
		返回值:返回进程号
		示例:见fork1.py

	进程退出
		os._exit(status)
		功能:进程退出
		参数:进程的退出状态
		sys.exit([status])
		功能:进程退出
		参数:数字表示退出状态,不写默认为0
			字符串,表示退出时打印的内容
		* 父进程可以获取子进程退出状态
		* 父子进程是否退出,互不影响
		* sys.exit可以通过捕获SystemExit异常阻止退出
		示例:见exit.py

	孤儿进程:
		父进程先于子进程退出,此时子进程就称为孤儿进程
		* 孤儿进程会被操作系统指定的进程收养,系统进程就成为孤儿进程的父进程

	僵尸进程:
		子进程先于父进程退出,但是父进程没有处理子进程的退出状态,此时子进程就会成为僵尸进程
		* 僵尸进程会存留少量PCB信息在内存中,大量的僵尸进程会消耗系统资源,应该避免僵尸进程的产生
		示例:见fork_z.py

		如何避免僵尸进程产生
			* 处理子进程退出状态
				pid,status = os.wait()
					功能:在父进程中阻塞等待处理子进程退出
					返回值:pid 	 退出的子进程的PID号
					  	  status 获取子进程退出状态
				pid,status = os.waitpid(pid,option)
					功能:在父进程中阻塞等待处理子进程退出
					参数:pid -1 表示等待任意子进程退出
							>0 表示等待对应PID号的子进程退出
						option 0 表示阻塞等待
							   os.WNOHANG 表示非阻塞
					返回值:pid 	 退出的子进程的PID号
						  status 获取子进程退出状态
				os.waitpid(-1,0) ==> os.wait()
				示例见:wait.py

			* 让父进程先退出
				1. 父进程创建子进程等待子进程退出
				2. 子进程创建二级子进程后立即退出
				3. 二级子进程称为孤儿,和原来的父进程各自执行事件
				示例:
					fork_js.py